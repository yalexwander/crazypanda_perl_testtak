# Задание

5. Работа с памятью
Уровень: senior

```
while (1) {
my $a = {};
    $a->{func} = sub {
      $a->{cnt}++;
  };
}
```

Что произойдет с памятью в этом примере и почему? Как исправить положение?

Учтите, что это только искусственный пример - на практике $a чаще всего является долгоживущим объектом, который где-то хранится, и мы хотим иметь возможность звать на нём $a->{func}->() в других точках кода. Представьте, что вам надо дописать некий код в теле цикла так, чтобы можно было добавить $a->{func}->() в конце, и функция бы корректно вызвалась.


# Пояснение

Если расчет идет на вызов в других точках кода, то почему объект $a создается локально? Возможно имеется в виду другой вариант, например есть объект персонажа и в него в процессе игры навешивается разный функционал, но функция вызова одна?

```
my $a = {};

while (1) {
    $a->{func} = sub {
      $a->{cnt}++;
  };
}
```

Для такого случая файл main_2.pl . Тогда утечки памяти просто не будет, причем даже если убрать строчку

    delete $a->{func} if defined($a->{func});
    
Для буквального соответствия задания есть файл main.pl, там достаточно сделать слабую ссылку, чтобы не было утечки памяти. Но логика непонятна.
